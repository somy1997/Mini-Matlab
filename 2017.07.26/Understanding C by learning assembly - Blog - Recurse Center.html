<!DOCTYPE html>
<!-- saved from url=(0067)https://www.recurse.com/blog/7-understanding-c-by-learning-assembly -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="The Recurse Center is a self-directed, community-driven educational retreat for programmers in New York City.">
  <meta name="keywords" content="programming, retreat, sabbatical, New York City, free, workshop, unschool, unschooling">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Understanding C by learning assembly - Blog - Recurse Center">
  <meta property="og:description" content="The Recurse Center is a self-directed, community-driven educational retreat for programmers in New York City.">
  <meta property="og:url" content="https://www.recurse.com/">
  <meta property="og:image" content="https://d29xw0ra2h4o4u.cloudfront.net/assets/logo_square-051508b5ecf8868635aea567bb86f423f4d1786776e5dfce4adf2bc7edf05804.png">
  <meta property="og:site_name" content="Recurse Center">
  <meta property="og:locale" content="en_US">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@RecurseCenter">
  <meta name="twitter:title" content="Understanding C by learning assembly - Blog - Recurse Center">
  <meta name="twitter:description" content="The Recurse Center is a self-directed, community-driven educational retreat for programmers in New York City.">
  <meta name="twitter:image" content="https://d29xw0ra2h4o4u.cloudfront.net/assets/logo_square-051508b5ecf8868635aea567bb86f423f4d1786776e5dfce4adf2bc7edf05804.png">


  <meta name="csrf-param" content="authenticity_token">
<meta name="csrf-token" content="QDMrdUqMdndZBkF3/kYH2v/1F7In3ATYxoy2oCw+QzblQ0VGuccwwlJjkJWFGiY72I7rjUNItOF3x5TxesAdkQ==">

  <link rel="alternate" type="application/rss+xml" title="The Recurse Center Blog" href="https://www.recurse.com/blog.rss">

  <script type="text/javascript" async="" src="./Understanding C by learning assembly - Blog - Recurse Center_files/ga.js"></script><script type="text/javascript" async="" src="./Understanding C by learning assembly - Blog - Recurse Center_files/heap-3935893124.js"></script><script src="./Understanding C by learning assembly - Blog - Recurse Center_files/heap-9444d05321b05558933000ef8e71305b7a50ff80ed79da557efc8254b504dd0c.js"></script>

  <link rel="stylesheet" media="screen" href="./Understanding C by learning assembly - Blog - Recurse Center_files/bem_public-ab94ed828983f4f784e0a31985ebb5e1bc4eb35eab7a59e841a77ef000e102b5.css">
  <link href="./Understanding C by learning assembly - Blog - Recurse Center_files/css" rel="stylesheet">

  <!--[if lt IE 9]
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js">
-->

<script src="./Understanding C by learning assembly - Blog - Recurse Center_files/public-609d14ee20cd1d989a58f37ba3d669bcdfcb995e57191e6a6f2ea0c591582633.js"></script><meta class="foundation-data-attribute-namespace"><meta class="foundation-mq-xxlarge"><meta class="foundation-mq-xlarge-only"><meta class="foundation-mq-xlarge"><meta class="foundation-mq-large-only"><meta class="foundation-mq-large"><meta class="foundation-mq-medium-only"><meta class="foundation-mq-medium"><meta class="foundation-mq-small-only"><meta class="foundation-mq-small"><style></style>



  <title>Understanding C by learning assembly - Blog - Recurse Center</title>
<meta class="foundation-mq-topbar"></head>
<body class="public-page">

  <header class="public-header public-page__skew-bg ">
    <div class="public-header__login-container">
        <a class="public-header__login-link" href="https://www.recurse.com/login">Log in</a>
    </div>

    <div class="public-content">
        <a href="https://www.recurse.com/" class="brand-link color-white public-header__logo">
          <div data-react-class="RC.Logo" data-react-props="{&quot;scale&quot;:3,&quot;variant&quot;:&quot;brand-link-logo&quot;}"><div data-reactroot="" class="rc-logo--brand-link-logo" style="height: 45px; width: 36px;"><!-- When you edit this file, make sure to bump the version in assets.es6.erb -->
<svg class="rc-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 15">
  <rect class="rc-logo__primary" x="0" y="0" width="12" height="1" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="0" y="0" width="1" height="10" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="11" y="0" width="1" height="10" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="0" y="9" width="12" height="1" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="4" y="9" width="4" height="3" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="1" y="11" width="10" height="1" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="1" y="11" width="1" height="4" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="10" y="11" width="1" height="4" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="1" y="14" width="10" height="1" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="0" y="12" width="2" height="3" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="10" y="12" width="2" height="3" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="10" y="12" width="2" height="3" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="1" y="11" width="2" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="4" y="11" width="1" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="6" y="11" width="1" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="8" y="11" width="1" height="2" fill="#2a2d2d"></rect>

  <rect class="rc-logo__primary" x="9" y="13" width="2" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="7" y="13" width="1" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="5" y="13" width="1" height="2" fill="#2a2d2d"></rect>
  <rect class="rc-logo__primary" x="3" y="13" width="1" height="2" fill="#2a2d2d"></rect>

  <rect class="rc-logo__secondary" x="1" y="1" width="10" height="8" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="2" y="13" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="3" y="12" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="4" y="13" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="5" y="12" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="6" y="13" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="7" y="12" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="8" y="13" width="1" height="1" fill="#fff"></rect>
  <rect class="rc-logo__secondary" x="9" y="12" width="1" height="1" fill="#fff"></rect>

  <rect class="rc-logo__primary" x="2" y="2" width="8" height="6" fill="#2a2d2d"></rect>

  <rect class="rc-logo__accent rc-logo__pixel1" x="2" y="3" width="1" height="1" fill="#3dc06c"></rect>
  <rect class="rc-logo__accent rc-logo__pixel2" x="4" y="3" width="1" height="1" fill="#3dc06c"></rect>
  <rect class="rc-logo__accent rc-logo__pixel3" x="6" y="3" width="1" height="1" fill="#3dc06c"></rect>
  <rect class="rc-logo__accent rc-logo__pixel4" x="3" y="5" width="2" height="1" fill="#3dc06c"></rect>
  <rect class="rc-logo__accent rc-logo__pixel5" x="6" y="5" width="2" height="1" fill="#3dc06c"></rect>
</svg>
</div></div>
        </a>

      <nav>
        <a class="color-blue hover-color-dark-blue public-header__nav-link" href="https://www.recurse.com/about">About</a>
        <a class="color-purple hover-color-dark-purple public-header__nav-link" href="https://www.recurse.com/faq">FAQ</a>
        <a class="color-pink hover-color-dark-pink public-header__nav-link" href="https://www.recurse.com/manual">Manual</a>
        <a class="color-orange hover-color-dark-orange public-header__nav-link" href="https://www.recurse.com/blog">Blog</a>
        <a class="color-green hover-color-dark-green public-header__nav-link" href="https://www.recurse.com/apply">Apply</a>
      </nav>

      
    </div>
  </header>

  <div class="public-page__content">
    <article class="public-content public-article public-article--blog">
  <h1 class="public-article__title">
      Understanding C by learning assembly
  </h1>

  <div class="blog-author">
    <div class="blog-author__info">
      <img class="blog-author__avatar real-circular-image real-circular-image--xsmall bg-lightest-gray" src="./Understanding C by learning assembly - Blog - Recurse Center_files/david_albert_circle-e2e35055d295951595af84af729a7b6d521a13073938f31b03d5e1791c9deef9.png" alt="David albert circle">

      <a class="blog-author__author-link" href="https://github.com/davidbalbert">David Albert</a>

      <time class="blog-author__pubdate" datetime="2012-09-12" pubdate="">
        Sep 12, 2012
      </time>
    </div>

    <div class="blog-author__share-buttons">
      <a class="blog-author__share color-blue hover-color-dark-blue" href="http://twitter.com/intent/tweet?text=Understanding+C+by+learning+assembly&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fwww.recurse.com%2Fblog%2F7-understanding-c-by-learning-assembly&amp;via=recursecenter">
        <i class="fa fa-twitter"></i>
      </a>
    </div>
  </div>

  <div class="public-article__columns">
    <div class="public-text public-text--blog">
      <p>Last time, <a href="https://github.com/happy4crazy">Alan</a> showed how to use <a href="https://www.hackerschool.com/blog/5-learning-c-with-gdb">GDB as a tool to learn C</a>. Today I want to go one step further and use GDB to help us understand assembly as well.</p>

<p>Abstraction layers are great tools for building things, but they can sometimes get in the way of learning. My goal in this post is to convince you that in order to rigorously understand C, we must also understand the assembly that our C compiler generates. I’ll do this by showing you how to disassemble and read a simple program with GDB, and then we’ll use GDB and our knowledge of assembly to understand how static local variables work in C.</p>

<p><em>Note: All the code in this post was compiled on an x86_64 CPU running Mac OS X 10.8.1 using Clang 4.0 with optimizations disabled (</em><code>-O0</code><em>).</em></p>

<h2>Learning assembly with GDB</h2>

<p>Let’s start by disassembling a program with GDB and learning how to read the output. Type the following program into a text file and save it as <code>simple.c</code>:</p>

<pre><code class="c cpp"><span class="keyword">int</span> main()
{
    <span class="keyword">int</span> a = <span class="number">5</span>;
    <span class="keyword">int</span> b = a + <span class="number">6</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

<p>Now compile it with debugging symbols and no optimizations and then run GDB:<sup id="footnote_return_p7f1"><a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_p7f1">1</a></sup></p>

<pre><code class="sh undefined">$ CFLAGS="-g -O0" make simple
cc -g -O0    simple.c   -o simple
$ gdb simple
</code></pre>

<p>Inside GDB, we’ll break on <code>main</code> and run until we get to the return statement. We put the number 2 after <code>next</code> to specify that we want to run <code>next</code> twice:</p>

<pre><code class="gdb cpp">(gdb) <span class="keyword">break</span> main
(gdb) run
(gdb) next <span class="number">2</span>
</code></pre>

<p>Now let’s use the <code>disassemble</code> command to show the assembly instructions for the current function. You can also pass a function name to <code>disassemble</code> to specify a different function to examine.</p>

<pre><code class="gdb cpp">(gdb) disassemble
Dump of assembler code <span class="keyword">for</span> function main:
<span class="number">0x0000000100000f50</span> &lt;main+<span class="number">0</span>&gt;:    push   %rbp
<span class="number">0x0000000100000f51</span> &lt;main+<span class="number">1</span>&gt;:    mov    %rsp,%rbp
<span class="number">0x0000000100000f54</span> &lt;main+<span class="number">4</span>&gt;:    mov    $<span class="number">0x0</span>,%eax
<span class="number">0x0000000100000f59</span> &lt;main+<span class="number">9</span>&gt;:    movl   $<span class="number">0x0</span>,-<span class="number">0x4</span>(%rbp)
<span class="number">0x0000000100000f60</span> &lt;main+<span class="number">16</span>&gt;:   movl   $<span class="number">0x5</span>,-<span class="number">0x8</span>(%rbp)
<span class="number">0x0000000100000f67</span> &lt;main+<span class="number">23</span>&gt;:   mov    -<span class="number">0x8</span>(%rbp),%ecx
<span class="number">0x0000000100000f6a</span> &lt;main+<span class="number">26</span>&gt;:   add    $<span class="number">0x6</span>,%ecx
<span class="number">0x0000000100000f70</span> &lt;main+<span class="number">32</span>&gt;:   mov    %ecx,-<span class="number">0xc</span>(%rbp)
<span class="number">0x0000000100000f73</span> &lt;main+<span class="number">35</span>&gt;:   pop    %rbp
<span class="number">0x0000000100000f74</span> &lt;main+<span class="number">36</span>&gt;:   retq   
End of assembler dump.
</code></pre>

<p>The <code>disassemble</code> command defaults to outputting instructions in AT&amp;T syntax, which is the same syntax used by the GNU assembler.<sup id="footnote_return_p7f2"><a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_p7f2">2</a></sup> Instructions in AT&amp;T syntax are of the format <code>mnemonic  source, destination</code>. The mnemonic is a human readable name for the instruction. Source and destination are operands and can be immediate values, registers, memory addresses, or labels. Immediate values are constants, and are prefixed by a <code>$</code>. For instance, <code>$0x5</code> represents the number 5 in hexadecimal. Register names are prefixed by a <code>%</code>.</p>

<h3>Registers</h3>

<p>It’s worth taking a quick detour to understand registers. Registers are data storage locations directly on the CPU. With some exceptions, the size, or <em>width</em>, of a CPU’s registers define its architecture. So if you have a 64-bit CPU, your registers will be 64 bits wide. The same is true of 32-bit CPUs (32-bit registers), 16-bit CPUs, and so on.<sup id="footnote_return_p7f3"><a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_p7f3">3</a></sup> Registers are very fast to access and are often the operands for arithmetic and logic operations.</p>

<p>The x86 family has a number of general and special purpose registers. General purpose registers can be used for any operation and their value has no particular meaning to the CPU. On the other hand, the CPU relies on special purpose registers for its own operation and the values stored in them have a specific meaning depending on the register. In our example above, <code>%eax</code> and <code>%ecx</code> are general purpose registers, while <code>%rbp</code> and <code>%rsp</code> are special purpose registers. <code>%rbp</code> is the base pointer, which points to the base of the current stack frame, and <code>%rsp</code> is the stack pointer, which points to the top of the current stack frame. <code>%rbp</code> always has a higher value than <code>%rsp</code> because the stack starts at a high memory address and grows downwards. If you are unfamiliar with the call stack, you can find a <a href="http://en.wikipedia.org/wiki/Call_stack">good introduction on Wikipedia</a>.</p>

<p>One quirk of the x86 family is that it has maintained backwards compatibility all the way back to the 16-bit 8086 processor. As x86 moved from 16-bit to 32-bit to 64-bit, the registers were expanded and given new names so as to not break backwards compatibility with code that was written for older, narrower CPUs.</p>

<p>Take the general purpose register AX, which is 16 bits wide. The high byte can be accessed with the name AH, and the low byte with the name AL. When the 32-bit 80386 came out, the Extended AX register, or EAX, referred to the 32-bit register, while AX continued to refer to a 16-bit register that made up the lower half of EAX. Similarly, when the x86_64 architecture came out, the “R” prefix was used and EAX made up the lower half of the 64-bit RAX register. I’ve included a diagram below based on a <a href="http://en.wikipedia.org/wiki/X86#x86_registers">Wikipedia article</a> to help visualize the relationships I described:</p>

<pre><code class="undefined">|__64__|__56__|__48__|__40__|__32__|__24__|__16__|__8___|
|__________________________RAX__________________________|
|xxxxxxxxxxxxxxxxxxxxxxxxxxx|____________EAX____________|
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|_____AX______|
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|__AH__|__AL__|
</code></pre>

<h3>Back to the code</h3>

<p>This should be enough information to start reading our disassembled program.</p>

<pre><code class="gdb undefined">0x0000000100000f50 &lt;main+0&gt;:    push   %rbp
0x0000000100000f51 &lt;main+1&gt;:    mov    %rsp,%rbp
</code></pre>

<p>The first two instructions are called the function prologue or preamble. First we push the old base pointer onto the stack to save it for later. Then we copy the value of the stack pointer to the base pointer. After this, <code>%rbp</code> points to the base of <code>main</code>‘s stack frame.</p>

<pre><code class="gdb undefined">0x0000000100000f54 &lt;main+4&gt;:    mov    $0x0,%eax
</code></pre>

<p>This instruction copies 0 into <code>%eax</code>. The x86 calling convention dictates that a function’s return value is stored in <code>%eax</code>, so the above instruction sets us up to return 0 at the end of our function.</p>

<pre><code class="gdb undefined">0x0000000100000f59 &lt;main+9&gt;:    movl   $0x0,-0x4(%rbp)
</code></pre>

<p>Here we have something we haven’t encountered before: <code>-0x4(%rbp)</code>. The parentheses let us know that this is a memory address. Here, <code>%rbp</code> is called the base register, and <code>-0x4</code> is the displacement. This is equivalent to <code>%rbp + -0x4</code>. Because the stack grows downwards, subtracting 4 from the base of the current stack frame moves us into the current frame itself, where local variables are stored. This means that this instruction stores 0 at <code>%rbp - 4</code>. It took me a while to figure out what this line was for, but it seems that clang <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2012-February/019767.html">allocates a hidden local variable</a> for an implicit return value from <code>main</code>.</p>

<p>You’ll also notice that the mnemonic has the suffix <code>l</code>. This signifies that the operands will be <code>l</code>ong (32 bits for integers). Other valid suffixes are <code>b</code>yte, <code>s</code>hort, <code>w</code>ord, <code>q</code>uad, and <code>t</code>en. If you see an instruction that does not have a suffix, the size of the operands are inferred from the size of the source or destination register. For instance, in the previous line, <code>%eax</code> is 32 bits wide, so the <code>mov</code> instruction is inferred to be <code>movl</code>.</p>

<pre><code class="gdb undefined">0x0000000100000f60 &lt;main+16&gt;:   movl   $0x5,-0x8(%rbp)
</code></pre>

<p>Now we’re getting into the meat of our sample program! The first line of assembly is the first line of C in <code>main</code> and stores the number 5 in the next available local variable slot (<code>%rbp - 0x8</code>), 4 bytes down from our last local variable. That’s the location of <code>a</code>. We can use GDB to verify this:</p>

<pre><code class="gdb undefined">(gdb) x &amp;a
0x7fff5fbff768: 0x00000005
(gdb) x $rbp - 8
0x7fff5fbff768: 0x00000005
</code></pre>

<p>Note that the memory addresses are the same. You’ll notice that GDB sets up variables for our registers, but like all variables in GDB, we prefix it with a <code>$</code> rather than the <code>%</code> used in AT&amp;T assembly.</p>

<pre><code class="gdb undefined">0x0000000100000f67 &lt;main+23&gt;:   mov    -0x8(%rbp),%ecx
0x0000000100000f6a &lt;main+26&gt;:   add    $0x6,%ecx
0x0000000100000f70 &lt;main+32&gt;:   mov    %ecx,-0xc(%rbp)
</code></pre>

<p>We then move <code>a</code> into <code>%ecx</code>, one of our general purpose registers, add 6 to it and store the result in <code>%rbp - 0xc</code>. This is the second line of C in <code>main</code>. You’ve maybe figured out that <code>%rbp - 0xc</code> is <code>b</code>, which we can verify in GDB:</p>

<pre><code class="gdb undefined">(gdb) x &amp;b
0x7fff5fbff764: 0x0000000b
(gdb) x $rbp - 0xc
0x7fff5fbff764: 0x0000000b
</code></pre>

<p>The rest of <code>main</code> is just cleanup, called the function epilogue:</p>

<pre><code class="gdb undefined">0x0000000100000f73 &lt;main+35&gt;:   pop    %rbp
0x0000000100000f74 &lt;main+36&gt;:   retq   
</code></pre>

<p>We <code>pop</code> the old base pointer off the stack and store it back in <code>%rbp</code> and then <code>retq</code> jumps back to our return address, which is also stored in the stack frame.</p>

<p>So far we’ve used GDB to disassemble a short C program, gone over how to read AT&amp;T assembly syntax, and covered registers and memory address operands. We’ve also used GDB to verify where our local variables are stored in relation to <code>%rbp</code>. Now we’re going to use our newly acquired skills to explain how static local variables work.</p>

<h2>Understanding static local variables</h2>

<p>Static local variables are a very cool feature of C. In a nutshell, they are local variables that only get initialized once and persist their values across multiple calls to the function where they are defined. A simple use case for static local variables is a Python-style generator. Here’s one that generates all of the natural numbers up to <code>INT_MAX</code>:</p>

<pre><code class="c cpp"><span class="comment">/* static.c */</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="keyword">int</span> natural_generator()
{
        <span class="keyword">int</span> a = <span class="number">1</span>;
        <span class="keyword">static</span> <span class="keyword">int</span> b = -<span class="number">1</span>;
        b += <span class="number">1</span>;
        <span class="keyword">return</span> a + b;
}

<span class="keyword">int</span> main()
{
        printf(<span class="string">"%d\n"</span>, natural_generator());
        printf(<span class="string">"%d\n"</span>, natural_generator());
        printf(<span class="string">"%d\n"</span>, natural_generator());

        <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

<p>When compiled and run, this program prints the first three natural numbers:</p>

<pre><code class="cpp">$ CFLAGS=<span class="string">"-g -O0"</span> make <span class="keyword">static</span>
cc -g -O0    <span class="keyword">static</span>.c   -o <span class="keyword">static</span>
$ ./<span class="keyword">static</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
</code></pre>

<p>But how does this work? To understand static locals, we’re going to jump into GDB and look at the assembly. I’ve removed the address information that GDB adds to the disassembly so that everything fits on screen:</p>

<pre><code class="cpp">$ gdb <span class="keyword">static</span>
(gdb) <span class="keyword">break</span> natural_generator
(gdb) run
(gdb) disassemble
Dump of assembler code <span class="keyword">for</span> function natural_generator:
push   %rbp
mov    %rsp,%rbp
movl   $<span class="number">0x1</span>,-<span class="number">0x4</span>(%rbp)
mov    <span class="number">0x177</span>(%rip),%eax        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
add    $<span class="number">0x1</span>,%eax
mov    %eax,<span class="number">0x16c</span>(%rip)        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
mov    -<span class="number">0x4</span>(%rbp),%eax
add    <span class="number">0x163</span>(%rip),%eax        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
pop    %rbp
retq   
End of assembler dump.
</code></pre>

<p>The first thing we need to do is figure out what instruction we’re on. We can do that by examining the instruction pointer or program counter. The instruction pointer is a register that stores the memory address of the next instruction. On x86_64, that register is <code>%rip</code>. We can access the instruction pointer using the <code>$rip</code> variable, or alternatively we can use the architecture independent <code>$pc</code>:</p>

<pre><code class="gdb undefined">(gdb) x/i $pc
0x100000e94 &lt;natural_generator+4&gt;:  movl   $0x1,-0x4(%rbp)
</code></pre>

<p>The instruction pointer always contains the address of the <em>next</em> instruction to be run, which means the third instruction hasn’t been run yet, but is about to be.</p>

<p>Because knowing the next instruction is useful, we’re going to make GDB show us the next instruction every time the program stops. In GDB 7.0 or later, you can just run <code>set disassemble-next-line on</code>, which shows all the instructions that make up the next line of source, but we’re using Mac OS X, which only ships with GDB 6.3, so we’ll have to resort to the <code>display</code> command. <code>display</code> is like <code>x</code>, except it evaluates its expression every time our program stops:</p>

<pre><code class="gdb undefined">(gdb) display/i $pc
1: x/i $pc  0x100000e94 &lt;natural_generator+4&gt;:  movl   $0x1,-0x4(%rbp)
</code></pre>

<p>Now GDB is set up to always show us the next instruction before showing its prompt.</p>

<p>We’re already past the function prologue, which we covered earlier, so we’ll start right at the third instruction. This corresponds to the first source line that assigns 1 to <code>a</code>. Instead of <code>next</code>, which moves to the next source line, we’ll use <code>nexti</code>, which moves to the next assembly instruction. Afterwards we’ll examine <code>%rbp - 0x4</code> to verify our hypothesis that <code>a</code> is stored at <code>%rbp - 0x4</code>. </p>

<pre><code class="gdb cpp">(gdb) nexti
<span class="number">7</span>           b += <span class="number">1</span>;
<span class="number">1</span>: x/i $pc  mov   <span class="number">0x177</span>(%rip),%eax <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
(gdb) x $rbp - <span class="number">0x4</span>
<span class="number">0x7fff5fbff78c</span>: <span class="number">0x00000001</span>
(gdb) x &amp;a
<span class="number">0x7fff5fbff78c</span>: <span class="number">0x00000001</span>
</code></pre>

<p>They are the same, just as we expected. The next instruction is more interesting:</p>

<pre><code class="gdb cpp">mov    <span class="number">0x177</span>(%rip),%eax        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
</code></pre>

<p>This is where we’d expect to find the line <code>static int b = -1;</code>, but it looks substantially different than anything we’ve seen before. For one thing, there’s no reference to the stack frame where we’d normally expect to find local variables. There’s not even a <code>-0x1</code>! Instead, we have an instruction that loads <code>0x100001018</code>, located somewhere after the instruction pointer, into <code>%eax</code>. GDB gives us a helpful comment with the result of the memory operand calculation and a hint telling us that <code>natural_generator.b</code> is stored at this address. Let’s run this instruction and figure out what’s going on:</p>

<pre><code class="gdb undefined">(gdb) nexti
(gdb) p $rax
$3 = 4294967295
(gdb) p/x $rax
$5 = 0xffffffff
</code></pre>

<p>Even though the disassembly shows <code>%eax</code> as the destination, we print <code>$rax</code>, because GDB only sets up variables for full width registers. </p>

<p>In this situation, we need to remember that while variables have types that specify if they are signed or unsigned, registers don’t, so GDB is printing the value of <code>%rax</code> unsigned. Let’s try again, by casting <code>%rax</code> to a signed <code>int</code>:</p>

<pre><code class="gdb cpp">(gdb) p (<span class="keyword">int</span>)$rax
$<span class="number">11</span> = -<span class="number">1</span>
</code></pre>

<p>It looks like we’ve found <code>b</code>. We can double check this by using the <code>x</code> command:</p>

<pre><code class="gdb undefined">(gdb) x/d 0x100001018
0x100001018 &lt;natural_generator.b&gt;:  -1
(gdb) x/d &amp;b
0x100001018 &lt;natural_generator.b&gt;:  -1
</code></pre>

<p>So not only is <code>b</code> stored at a low memory address outside of the stack, it’s also initialized to -1 before <code>natural_generator</code> is even called. In fact, even if you disassembled the entire program, you wouldn’t find any code that sets <code>b</code> to -1. This is because the value for <code>b</code> is hardcoded in a different section of the <code>sample</code> executable, and it’s loaded into memory along with all the machine code by the operating system’s loader when the process is launched.<sup id="footnote_return_p7f4"><a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_p7f4">4</a></sup></p>

<p>With this out of the way, things start to make more sense. After storing <code>b</code> in <code>%eax</code>, we move to the next line of source where we increment <code>b</code>. This corresponds to the next two instructions:</p>

<pre><code class="gdb cpp">add    $<span class="number">0x1</span>,%eax
mov    %eax,<span class="number">0x16c</span>(%rip)        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
</code></pre>

<p>Here we add 1 to <code>%eax</code> and store the result back into memory. Let’s run these instructions and verify the result:</p>

<pre><code class="gdb cpp">(gdb) nexti <span class="number">2</span>
(gdb) x/d &amp;b
<span class="number">0x100001018</span> &lt;natural_generator.b&gt;:  <span class="number">0</span>
(gdb) p (<span class="keyword">int</span>)$rax
$<span class="number">15</span> = <span class="number">0</span>
</code></pre>

<p>The next two instructions set us up to return <code>a + b</code>:</p>

<pre><code class="gdb cpp">mov    -<span class="number">0x4</span>(%rbp),%eax
add    <span class="number">0x163</span>(%rip),%eax        <span class="preprocessor"># 0x100001018 &lt;natural_generator.b&gt;</span>
</code></pre>

<p>Here we load <code>a</code> into <code>%eax</code> and then add <code>b</code>. At this point, we’d expect <code>%eax</code> to be 1. Let’s verify:</p>

<pre><code class="gdb undefined">(gdb) nexti 2
(gdb) p $rax
$16 = 1
</code></pre>

<p><code>%eax</code> is used to store the return value from <code>natural_generator</code>, so we’re all set up for the epilogue which cleans up the stack and returns:</p>

<pre><code class="gdb undefined">pop    %rbp
retq   
</code></pre>

<p>Now we understand how <code>b</code> is initialized, let’s see what happens when we run <code>natural_generator</code> again:</p>

<pre><code class="gdb cpp">(gdb) <span class="keyword">continue</span>
Continuing.
<span class="number">1</span>

Breakpoint <span class="number">1</span>, natural_generator () at <span class="keyword">static</span>.c:<span class="number">5</span>
<span class="number">5</span>           <span class="keyword">int</span> a = <span class="number">1</span>;
<span class="number">1</span>: x/i $pc  <span class="number">0x100000e94</span> &lt;natural_generator+<span class="number">4</span>&gt;:  movl   $<span class="number">0x1</span>,-<span class="number">0x4</span>(%rbp)
(gdb) x &amp;b
<span class="number">0x100001018</span> &lt;natural_generator.b&gt;:  <span class="number">0</span>
</code></pre>

<p>Because <code>b</code> is not stored on the stack with other local variables, it’s still zero when <code>natural_generator</code> is called again. No matter how many times our generator is called, <code>b</code> will always retain its previous value. This is because it’s stored outside the stack and initialized when the loader moves the program into memory, rather than by any of our machine code.</p>

<h2>Conclusion</h2>

<p>We began by going over how to read assembly and how to disassemble a program with GDB. Afterwards, we covered how static local variables work, which we could not have done without disassembling our executable.</p>

<p>We spent a lot of time alternating between reading the assembly instructions and verifying our hypotheses in GDB. It may seem repetitive, but there’s a very important reason for doing things this way: the best way to learn something abstract is to make it more concrete, and one of the best way to make something more concrete is to use tools that let you peel back layers of abstraction. The best way to to learn these tools is to force yourself to use them until they’re second nature.</p>

<ol class="footnotes">
    <li id="footnote_p7f1">
        <p>
            You’ll notice we’re using Make to build `simple.c` without a makefile. We can do this because Make has implicit rules for building executables from C files. You can find more information about these rules in the [Make manual](http://www.gnu.org/software/make/manual/make.html#Implicit-Rules). <a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_return_p7f1">↩</a>
        </p>
    </li>
    <li id="footnote_p7f2">
        <p>
            You can also have GDB output Intel syntax, which is used by NASM, MASM, and other assemblers, but that’s outside the scope of this post. <a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_return_p7f2">↩</a>
        </p>
    </li>
    <li id="footnote_p7f3">
        <p>
            Processors with SIMD instruction sets like MMX and SSE for x86 and AltiVec for PowerPC will often contain some registers that are wider than the CPU architecture.<a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_return_p7f3">↩</a>
        </p>
    </li>
    <li id="footnote_p7f4">
        <p>
            A discussion of object formats, loaders, and linkers is best saved for a future blog post.<a href="https://www.recurse.com/blog/7-understanding-c-by-learning-assembly#footnote_return_p7f4">↩</a>
        </p>
    </li>
</ol>

    </div>

    <aside class="public-article__aside public-article__aside--further-reading">
        <section class="other-links">
          <div data-react-class="RC.FollowScroll" data-react-props="{&quot;pxFromTop&quot;:100,&quot;innerHTML&quot;:&quot;\n              \u003cdiv class=\&quot;other-links__inner\&quot;\u003e\n                \u003ch1\u003eRecent posts\u003c/h1\u003e\n                \u003cnav\u003e\n                  \u003ca href=\&quot;/blog/116-happy-6th-birthday-rc\&quot;\u003eHappy 6th birthday, RC\u003c/a\u003e\n\u003ca href=\&quot;/blog/115-join-rc-and-build-useful-software\&quot;\u003eJoin the Recurse Center and build useful software\u003c/a\u003e\n\u003ca href=\&quot;/blog/114-never-graduate-week-2017-how-we-planned-and-ran-our-annual-alumni-week\&quot;\u003eNever Graduate Week 2017: how we planned and ran our annual alumni week\u003c/a\u003e\n                \u003c/nav\u003e\n              \u003c/div\u003e\n            &quot;}" class="full-width"><div data-reactroot=""><div>
              <div class="other-links__inner">
                <h1>Recent posts</h1>
                <nav>
                  <a href="https://www.recurse.com/blog/116-happy-6th-birthday-rc">Happy 6th birthday, RC</a>
<a href="https://www.recurse.com/blog/115-join-rc-and-build-useful-software">Join the Recurse Center and build useful software</a>
<a href="https://www.recurse.com/blog/114-never-graduate-week-2017-how-we-planned-and-ran-our-annual-alumni-week">Never Graduate Week 2017: how we planned and ran our annual alumni week</a>
                </nav>
              </div>
            </div></div></div>
        </section>
    </aside>
  </div>
</article>


  </div>

  <footer class="public-footer">
    <div class="public-content">
      <nav class="public-footer__nav">
        <section class="public-footer__nav-section">
          <a class="color-blue" href="https://www.recurse.com/about">About</a>
          <a class="color-purple" href="https://www.recurse.com/faq">FAQ</a>
          <a class="color-pink" href="https://www.recurse.com/code-of-conduct">Code of conduct</a>
          <a class="color-orange" href="https://www.recurse.com/blog">Blog</a>
          <a class="color-green" href="https://www.recurse.com/team">People</a>
          <a class="color-blue" href="https://www.recurse.com/hire">Hire</a>
        </section>
        <section class="public-footer__nav-section">
          <a class="button button--small bg-off-white color-dark-green border-green" href="https://www.recurse.com/apply">Apply</a>
        </section>
      </nav>
    </div>

    <div class="public-footer__bottom">
      <div class="public-content p-y-2 font-size-xxsmall">
        <form action="https://linkedlistnyc.us2.list-manage.com/subscribe/post?u=193b767bbb3b0eb0d949d5924&amp;id=c8d3ac8bbf" method="post" name="mc-embedded-subscribe-form" class="new-form display-flex align-items-center" target="_blank" id="email-signup-form">

          <a class="public-footer__twitter-link" href="https://twitter.com/recursecenter" target="_blank" rel="noopener noreferrer">
            <i class="fa fa-twitter public-footer__twitter-icon" aria-hidden="true"></i>
            <span class="hide-on-mobile">Follow us</span>
          </a>

          <div class="m-r-1">
            Get email updates
          </div>
          <label class="display-none" for="mce-EMAIL">Email</label>
          <input class="new-form__input new-form__input--inline m-r-1" id="mce-EMAIL" name="EMAIL" placeholder="email@example.com" type="email">
          <input class="font-size-xxsmall button bg-lightest-gray color-dark-gray" name="subscribe" type="submit" value="Sign up">
        </form>
      </div>
    </div>
  </footer>


</body></html>