<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0037)http://aquamentus.com/flex_bison.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Flex and Bison</title><link rel="stylesheet" href="./Flex and Bison_files/aquamentus-3.css" type="text/css">
</head>
<body>
<table width="100%" cellpadding="5"><tbody><tr>
<td rowspan="2"><img src="./Flex and Bison_files/aquamentus-gray.png"></td>
<td class="title">w w w . a q u a m e n t u s . c o m</td>
</tr></tbody></table>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#0">What are Flex and Bison?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#1">lex vs. flex, yacc vs. bison</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#2">what we'll do!</a><br>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#3">Flex</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#4">reading from a file</a><br>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#5">Bison</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#6">a makefile</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#7">forcing carriage returns</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#8">line numbers</a><br>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#9">Tips</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#10">directly returning terminal characters</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#11">actions before the end of the grammar</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#12">whitespace in flex/bison files</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#13">avoiding -lfl and link problems with yywrap</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#14">renaming identifiers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#15">moving output</a><br>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#16">Advanced</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#17">start states</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#18">reading gzipped input</a><br>
&nbsp;&nbsp;<a href="http://aquamentus.com/flex_bison.html#19">Regular expression overview</a><br>
<p></p><p><a name="0"></a>
</p><h1>What are Flex and Bison?</h1>
<p>Flex and Bison are aging unix utilities that help you write very fast
parsers for almost arbitrary file formats.  Formally, they
implement Look-Ahead-Left-Right (as opposed to "recursive descent") parsing
of non-ambiguous context-free (as opposed to "natural language") grammars.
</p><p>Why should you learn the Flex/Bison pattern syntax when you could just write
your own parser?  Well, several reasons.  First, Flex and Bison will
generate a parser that is virually guaranteed to be faster than anything you
could write manually in a reasonable amount of time.  Second, updating and
fixing Flex and Bison source files is a lot easier than updating and
fixing custom parser code.  Third, Flex and Bison have mechanisms
for error handling and recovery, which is something you definitely don't
want to try to bolt onto a custom parser.  Finally, Flex and Bison have
been around for a long time, so they far freer from bugs than newer code.
</p><p>This webpage is supposed to be a tutorial for complete novices needing to use
Flex and Bison for some real project.  I wrote it as I was learning them, so
hopefully it explains things right as you need to know them.  (The Flex and
Bison tutorials I found Googling around tended to be really heavy on 
theory and details.)
</p><p><a name="1"></a>
</p><h2>lex vs. flex, yacc vs. bison</h2>
<p>In addition to hearing about "flex and bison", you will also hear about "lex
and yacc".  "lex and yacc" are the original tools; "flex and bison" are their
almost completely compatible newer versions.  Only very old code uses lex and
yacc; most of the world has moved on to Flex and Bison.
</p><p>All four of the above are C-based tools; they're written in C, but more
important their output is C code.  However, my project was in C++ -- so this
is also a tutorial on how to use C++ with Flex and Bison!
</p><p></p><p><a name="2"></a>
</p><h2>what we'll do!</h2>
<p>Let's create a Flex/Bison parser for a silly format that I'll call "snazzle".
Snazzle files have four general sections:
</p><ul>
<li>a header that just says "sNaZZle" followed by a version number,
</li><li>a section that declares type names, like "type foo" and "type bas",
</li><li>a section with actual data consisting of exactly 4 numbers and one of the aforementioned type names,
</li><li>and a footer that just says "end".
</li></ul>
(I don't have a particular file format or program in mind, I'm
just coming up with this.)  Here's an example of our silly format:
<p></p><pre class="snippet">sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5        foo
20 10 30 20     foo
7 8 12 13       bas
78 124 100 256  bar
end
</pre>
<p>For making parsers, you want to start at the high level because that's how
Bison thinks about them.  Happily, we already started at the high level by
saying that a "snazzlefile" is comprised
of four general parts; we'll call them "header", "typedefs", "body", and
"footer".  Then we describe any sub-parts that comprise each of those four 
general parts, and then what comprises each of the those sub-parts, and so on
until we get all the way down what are called <i>terminal symbols</i>.
Terminal symbols are the smallest units of your grammar -- for our example
here, integers like "15" are one of our terminal symbols.  (But
<i>not</i> the individual characters "1" and "5" that make it up.)  Terminal
symbols are the boundary between Flex and Bison: Flex sees the individual "1"
and "5" characters but combines them into "15" before giving it to Bison.
</p><p></p><p><a name="3"></a>
</p><h1>Flex</h1>
<p>For our silly snazzle files, we'll make 3 terminal symbol types: a NUMBER
that's basically an integer, a FLOAT that's a floating-point number (which
we only need for the version), and a STRING which is pretty much everything
else.  Furthermore, since this is a tutorial, let's show off Flex's power by
making a program that just lexes our input without using Bison to parse
it.  Here's the first whack:
</p><p></p><table>
<tbody><tr><th><u>snazzle.l</u></th>
</tr><tr>
<td width="0">
<pre class="snippet">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre>
</td>
<td>
<pre class="snippet">%{
#include &lt;iostream&gt;
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n]         ;
[0-9]+\.[0-9]+  { cout &lt;&lt; "Found a floating-point number:" &lt;&lt; yytext &lt;&lt; endl; }
[0-9]+          { cout &lt;&lt; "Found an integer:" &lt;&lt; yytext &lt;&lt; endl; }
[a-zA-Z0-9]+    { cout &lt;&lt; "Found a string: " &lt;&lt; yytext &lt;&lt; endl; }
%%
int main(int, char**) {
	// lex through the input:
	yylex();
}
</pre>
</td>
</tr>
</tbody></table>
<p>Flex and Bison files have three sections:
</p><ol>
<li>the first is sort of "control" information,
</li><li>the second is the actual token/grammar definitions,
</li><li>the last is C code to be copied verbatim to the output.
</li></ol>
These sections are divided by <code>%%</code>, which you see on lines 6 and 11.  Let's
go through this line by line.
<ul>
<li>Lines 1 (and 5) are delimeters that tell Flex that lines 2 through 4
are C code to be copied directly to the generated lexer.
</li><li>Lines 2 and 3 are to get access to <code>cout</code>.
</li><li>Line 4 is to force the g++ compiler to not apply "name-mangling" to the
<code>yylex</code> identifier.  If we don't do this, g++ generates the
function's name as something like "_Z5yylexv", where no one will ever be able
to find it or link to it.
</li><li>Line 6 is <code>%%</code>, which means we're done with the control section and
moving on to the token section.  Notice that we don't have much in our
control section -- the Bison control section gets a lot more usage than the
Flex one.  And here, we wouldn't need one at all if we weren't using this
from C++.
</li><li>Lines 7-10 are all the same (simple) format: a regular expression (a topic in its own right,
which I touch on not at all exhaustively at the end of this page)
and an action.  When Flex is reading through an input file and can match one of the
<i>regular expressions</i>, it executes the <i>action</i>.  The regular expression is <u>not</u> Perl's idea
of a regular expression, so you can't use "\d", but the normal stuff is all available.  The <i>action</i> is
just C code that is copied into the eventual flex output; accordingly, you can have a single statement
or you can have curly braces with a whole bunch of statements.  Some specifics on the file
format I discovered: the action has to be left-justified (if there's whitespace beginning
a line where a pattern is expected, the line is considered a comment!); the separation between the pattern
and the action is just whitespace (even just a single space will do); the action is not limited to a single
line if you use curly braces.
</li><li>Line 11 is another <code>%%</code> delimiter, meaning we're done with the second section and we can go
onto the third.
</li><li>Lines 12-15 are the third section, which is exclusively for copied C code.  (Notice
that, unlike the control section at the top, there is no "%{" or "%}".)  We
don't normally need to put anything in this section for the Flex file, but for this example we're going to
put a <code>main()</code> function in here so that we can execute the output without having to
make another file and link them together.
</li></ul>
<p>This example can be compiled by running this:
</p><pre class="snippet">% flex snazzle.l
</pre>
This will produce the file "lex.yy.c", which we can then compile with g++:
<pre class="snippet">% g++ lex.yy.c -lfl -o snazzle
</pre>
Notice the "-lfl", which links in the dynamic flex libraries.  (If you don't have Flex installed, and you
can't get it installed, you might try "-ll" instead -- that requests lex's .so instead of flex's .so.
If that doesn't work, ask someone who'll know where on your system the Flex libraries are kept.)  (Or,
leave the -l off completely, and do a quick Google search to figure out how to implement stub versions
of the missing functions it complains about.)
<p>If all went as planned, you should be able to run it and enter stuff on STDIN to be lexed:
</p><pre class="snippet">% ./snazzle
90
Found an integer:90
23.4
Found a floating-point number:23.4
4 5 6
Found an integer:4
Found an integer:5
Found an integer:6
this is text!
Found a string: this
Found a string: is
Found a string: text
 !
</pre>
<p>Pretty cool!  Notice that the exclamation mark at the very end was just echoed: when
Flex finds something that doesn't match any of the regexs it echos it to STDOUT.  Usually this
is a good indication that your token definitions aren't complete enough, but to get rid of it
for now you could just add ". ;" to the token section, which will match anything (the "." of
regex nomenclature) and do nothing with it (the empty C statement ";").
</p><p>Now for a little more detail on the syntax for the middle section.  In general, it is really
as simple as "a regex match" followed by "what to do with it".  The "what to do with it" can
vary a lot though - for example, most parsers completely ignore whitespace, which you can do by making
the "action" just a semicolon:
</p><pre class="snippet">[ \t] ;  // ignore all whitespace
</pre>
Most parsers also want to keep track of the line number, which you would do by catching
all the carriage returns and incrementing a line counter.  However, you want the carriage return
itself to be ignored as if it were whitespace, so even though you have an action
performed here you want to <i>not</i> put a <code>return</code> statement in it:
<pre class="snippet">\n    { ++linenum; }  // increment line count, but don't return a token
</pre>
Pretty much everything else will need to return a token to Bison, but more on that later.
<p></p><p><a name="4"></a>
</p><h2>reading from a file</h2>
<p>OK, first big upgrade: reading from a file.  Right now we're reading from STDIN, which is kind
of annoying, because most of the time you'd really like to pick a file
to read from.  Flex reads its input from a global pointer to a C <code>FILE</code> variable
called <code>yyin</code>, which is set to STDIN by default.  All you have to do is set
that pointer to your own file handle, and it'll read from it instead.  That changes our example
as follows (the differences are in bold):
</p><p></p><pre class="snippet"><u>snazzle.l</u>
%{
#include &lt;iostream&gt;
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n]          ;
[0-9]+\.[0-9]+   { cout &lt;&lt; "Found a floating-point number:" &lt;&lt; yytext &lt;&lt; endl; }
[0-9]+           { cout &lt;&lt; "Found an integer:" &lt;&lt; yytext &lt;&lt; endl; }
[a-zA-Z0-9]+     { cout &lt;&lt; "Found a string: " &lt;&lt; yytext &lt;&lt; endl; }
<b>.                ;</b>
%%
int main(int, char**) {
	<b>
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it's valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	</b>
	// lex through the input:
	yylex();
}
</pre>
<p>Here's how to run our new code, though there's nothing earth-shattering:
</p><p></p><pre class="snippet">% flex snazzle.l
% g++ lex.yy.c -lfl -o snazzle
% cat a.snazzle.file
90
23.4
4 5 6
this is text!
% ./snazzle
Found an integer:90
Found a floating-point number:23.4
Found an integer:4
Found an integer:5
Found an integer:6
Found a string: this
Found a string: is
Found a string: text
%
</pre>
<p></p><p></p><p><a name="5"></a>
</p><h1>Bison</h1>
<p>The first thing we have to do in our silly parser is to start defining the terminal
tokens, which for us are ints, floats, and strings.  Even though these are the types
of tokens (which is what Flex returns), defining token types is done
in the Bison file. We're also going to move <code>main()</code> into the copied-C-code section
of the Bison file now:
</p><p></p><pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING

%%
// this is the actual grammar that bison will parse, but for right now it's just
// something silly to echo to the screen what bison gets from flex.  We'll
// make a real one shortly:
snazzle:
	INT snazzle      { cout &lt;&lt; "bison found an int: " &lt;&lt; $1 &lt;&lt; endl; }
	| FLOAT snazzle  { cout &lt;&lt; "bison found a float: " &lt;&lt; $1 &lt;&lt; endl; }
	| STRING snazzle { cout &lt;&lt; "bison found a string: " &lt;&lt; $1 &lt;&lt; endl; }
	| INT            { cout &lt;&lt; "bison found an int: " &lt;&lt; $1 &lt;&lt; endl; }
	| FLOAT          { cout &lt;&lt; "bison found a float: " &lt;&lt; $1 &lt;&lt; endl; }
	| STRING         { cout &lt;&lt; "bison found a string: " &lt;&lt; $1 &lt;&lt; endl; }
	;
%%

int main(int, char**) {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it is valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	<b>
	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
	</b>
}
<b>
void yyerror(const char *s) {
	cout &lt;&lt; "EEK, parse error!  Message: " &lt;&lt; s &lt;&lt; endl;
	// might as well halt now:
	exit(-1);
}
</b>
</pre>
<p>Now that the Bison file knows what the terminal types are, we can use them
in the Flex file to make our life easier:
</p><p></p><pre class="snippet"><u>snazzle.l</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
#define YY_DECL extern "C" int yylex()

<b>#include "snazzle.tab.h"  // to get the token types that we return</b>

%}
%%
[ \t\n]           ;
<b>[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+            { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+      {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
</b>.                ;
%%
</pre>
<p>Since the Flex file now has to <code>#include</code> a file generated by
Bison (<code>snazzle.tab.h</code>), we have to run Bison first:
</p><p></p><pre class="snippet">% bison -d snazzle.y
% flex snazzle.l
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% ./snazzle
bison found a string: text
bison found a string: is
bison found a string: this
bison found an int: 6
bison found an int: 5
bison found an int: 4
bison found a float: 23.4
bison found an int: 90
%
</pre>
<p>You'll notice that the input is echoed out backward!  This is because for each of the
rules you define, Bison does not perform the <i>action</i> until it matches
the complete <i>rule</i>.  In the above example, all of the recursive rules were
right-recursive (i.e. they looked like "foo: bar foo", instead of "foo: foo bar").  The
right-recursive search will print the output backwards since it has to match EVERYTHING
before it can start figuring out what's what, AND it has another
major drawback: if your input is big enough, right-recursive rules will overflow
Bison's internal stack!  So a better implementation of the Bison grammar would be
left-recursion:
</p><p></p><pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING

%%
// this is the actual grammar that bison will parse, but for right now it's just
// something silly to echo to the screen what bison gets from flex.  We'll
// make a real one shortly:
snazzle:<b>
	snazzle INT { cout &lt;&lt; "bison found an int: " &lt;&lt; $2 &lt;&lt; endl; }
	| snazzle FLOAT { cout &lt;&lt; "bison found a float: " &lt;&lt; $2 &lt;&lt; endl; }
	| snazzle STRING { cout &lt;&lt; "bison found a string: " &lt;&lt; $2 &lt;&lt; endl; } </b>
	| INT { cout &lt;&lt; "bison found an int: " &lt;&lt; $1 &lt;&lt; endl; }
	| FLOAT { cout &lt;&lt; "bison found a float: " &lt;&lt; $1 &lt;&lt; endl; }
	| STRING { cout &lt;&lt; "bison found a string: " &lt;&lt; $1 &lt;&lt; endl; }
	;
%%

int main(int, char**) {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it is valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
}

void yyerror(const char *s) {
	cout &lt;&lt; "EEK, parse error!  Message: " &lt;&lt; s &lt;&lt; endl;
	// might as well halt now:
	exit(-1);
}
</pre>
<p>(Note that we also had to change the <code>$1</code> in the <code>cout</code> to a <code>$2</code> since the thing we wanted to print out
is now the second element in the rule.)  This gives us the output we would hope for:
</p><p></p><pre class="snippet">% bison -d snazzle.y
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% ./snazzle
bison found an int: 90
bison found a float: 23.4
bison found an int: 4
bison found an int: 5
bison found an int: 6
bison found a string: this
bison found a string: is
bison found a string: text
%
</pre>
<p>Now that the groundwork is completed, we can finally define the real file
format in the Bison file.  First we make the easy tokens: the ones that are used
to represent constant strings like SNAZZLE, TYPE, and END, respectively representing
the strings "sNaZZle", "type", and "end".  Then we flesh out the actual rules
in the Bison grammar, and end up with this beautiful object d'art:
</p><p></p><pre class="snippet"><u>snazzle.l</u>
%{
#include &lt;iostream&gt;
#include "snazzle.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n] ;
<b>sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }</b>
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
.              ;
%%
</pre>
<p></p><pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
<b>%token SNAZZLE TYPE
%token END</b>

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING

%%
<b>
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
	header template body_section footer { cout &lt;&lt; "done with a snazzle file!" &lt;&lt; endl; }
	;
header:
	SNAZZLE FLOAT { cout &lt;&lt; "reading a snazzle file version " &lt;&lt; $2 &lt;&lt; endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING { cout &lt;&lt; "new defined snazzle type: " &lt;&lt; $2 &lt;&lt; endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING { cout &lt;&lt; "new snazzle: " &lt;&lt; $1 &lt;&lt; $2 &lt;&lt; $3 &lt;&lt; $4 &lt;&lt; $5 &lt;&lt; endl; }
	;
footer:
	END
	;
</b>
%%

int main(int, char**) {
	// open a file handle to a particular file:
	<b>FILE *myfile = fopen("in.snazzle", "r");</b>
	// make sure it's valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout &lt;&lt; "EEK, parse error!  Message: " &lt;&lt; s &lt;&lt; endl;
	// might as well halt now:
	exit(-1);
}
</pre>
<p>This is compiled and run just like the others:
</p><pre class="snippet">% bison -d snazzle.y
% flex snazzle.l
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end

% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%
</pre>
<p>So, that concludes this little tutorial, or at least the baseline part of it.  I'm now going to
pick a few upgrades at random and show you how they might be done.
</p><p></p><p><a name="6"></a>
</p><h2>a makefile</h2>
<p>When you finally get sick of manually rerunning Flex and Bison, and also
forgetting in which order to do it, I heartily recommend setting up a
makefile.  Here's a sample one I made:
</p><p></p><pre class="snippet">% cat Makefile
snazzle.tab.c snazzle.tab.h: snazzle.y
	bison -d snazzle.y

lex.yy.c: snazzle.l snazzle.tab.h
	flex snazzle.l

snazzle: lex.yy.c snazzle.tab.c snazzle.tab.h
	g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% make snazzle
bison -d snazzle.y
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
%
</pre>
<p></p><p><a name="7"></a>
</p><h2>forcing carriage returns</h2>
<p>Next tweak: you'll notice that this completely ignores whitespace, so that you could put the entire
snazzle file on a single line and it'll still be okay.  You may or may not want this behaviour, but
let's assume that's bad, and require there to be carriage returns after the lines just like there
is in the sample file "in.snazzle".  To do this, we need to do two things: recognize the '\n' token
(flex), and add it to the grammar (bison):
</p><p></p><pre class="snippet"><u>snazzle.l</u>
%{
#include <iostream>
#include "snazzle.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t]          ;
sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
<b>\n             return ENDL;</b>
.              ;
%%
</iostream></pre>
<pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END <b>ENDL</b>

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING
%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
header template body_section footer { cout &lt;&lt; "done with a snazzle file!" &lt;&lt; endl; }
	;
header:
	<b>SNAZZLE FLOAT ENDL { cout &lt;&lt; "reading a snazzle file version " &lt;&lt; $2 &lt;&lt; endl; }</b>
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	<b>TYPE STRING ENDL { cout &lt;&lt; "new defined snazzle type: " &lt;&lt; $2 &lt;&lt; endl; }</b>
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	<b>INT INT INT INT STRING ENDL { cout &lt;&lt; "new snazzle: " &lt;&lt; $1 &lt;&lt; $2 &lt;&lt; $3 &lt;&lt; $4 &lt;&lt; $5 &lt;&lt; endl; }</b>
	;
footer:
	<b>END ENDL</b>
	;
%%

int main(int, char**) {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it's valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:	
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout &lt;&lt; "EEK, parse error!  Message: " &lt;&lt; s &lt;&lt; endl;
	// might as well halt now:
	exit(-1);
}
</pre>
<p>But when we go to run it, we get a parse error:
</p><pre class="snippet">% make
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
EEK, parse error!  Message: syntax error
%
</pre>
<p>Why??  Well, it turns out that <code>in.snazzle</code> has an extra
carriage return at the end:
</p><p></p><pre class="snippet">% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end

%
</pre>
<p>And if we remove it, snazzle would be happy:
</p><p></p><pre class="snippet">% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%
</pre>
<p>But that really isn't the best solution, as requiring all input files
to have exactly one carriage return after data is a little unreasonable.  We need to make it
more general.  Specifically, we should allow any number of carriage returns between lines.  In Bison-land,
this is best stated as "each line may be followed with one or more carriage returns", like so:
</p><p></p><pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END ENDL

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING

%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
header template body_section footer { cout &lt;&lt; "done with a snazzle file!" &lt;&lt; endl; }
	;
header:
	<b>SNAZZLE FLOAT ENDLS { cout &lt;&lt; "reading a snazzle file version " &lt;&lt; $2 &lt;&lt; endl; }</b>
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	<b>TYPE STRING ENDLS { cout &lt;&lt; "new defined snazzle type: " &lt;&lt; $2 &lt;&lt; endl; }</b>
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	<b>INT INT INT INT STRING ENDLS { cout &lt;&lt; "new snazzle: " &lt;&lt; $1 &lt;&lt; $2 &lt;&lt; $3 &lt;&lt; $4 &lt;&lt; $5 &lt;&lt; endl; }</b>
	;
footer:
	<b>END ENDLS</b>
	;
<b>ENDLS:
	ENDLS ENDL
	| ENDL ;</b>
%%
</pre>
<p>Note that this didn't require any changes to the flex file -- the underlying tokens didn't change, just
how we used them.  And of course, this actually works:
</p><p></p><pre class="snippet">% make
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas


0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas

78 124 100 256 bar

end


% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%
</pre>
<p></p><p><a name="8"></a>
</p><h2>line numbers</h2>
<p>Next little tweak: wouldn't it have been nice if that parse error had given us the line to look at, so that
we didn't have to guess-and-check the grammar?  Unfortunately Flex has no guaranteed way to get the line
number (well, there's <code>yylineno</code>, but it's almost completely manual, and in some
situations makes your parser very slow, so you might
as well just do it yourself).  The best way to keep track of the line number
is to have a global variable that you update whenever you see a carriage return:
</p><p></p><pre class="snippet"><u>snazzle.l</u>
%{
#include <iostream>
#include "snazzle.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
<b>int line_num = 1;</b>
%}
%%
<b>[ \t]          ;</b>
sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	yylval.sval = strdup(yytext);
	return STRING;
}
<b>\n             { ++line_num; return ENDL; }</b>
.              ;
%%
</iostream></pre>
<pre class="snippet"><u>snazzle.y</u>
%{
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
<b>extern int line_num;</b>
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END ENDL

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token &lt;ival&gt; INT
%token &lt;fval&gt; FLOAT
%token &lt;sval&gt; STRING

%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
	header template body_section footer { cout &lt;&lt; "done with a snazzle file!" &lt;&lt; endl; }
	;
header:
	SNAZZLE FLOAT ENDLS { cout &lt;&lt; "reading a snazzle file version " &lt;&lt; $2 &lt;&lt; endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING ENDLS { cout &lt;&lt; "new defined snazzle type: " &lt;&lt; $2 &lt;&lt; endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING ENDLS { cout &lt;&lt; "new snazzle: " &lt;&lt; $1 &lt;&lt; $2 &lt;&lt; $3 &lt;&lt; $4 &lt;&lt; $5 &lt;&lt; endl; }
	;
footer:
	END ENDLS
	;
ENDLS:
	ENDLS ENDL
	| ENDL ;
%%

int main(int, char**) {
	// open a file handle to a particular file:
	FILE *myfile = fopen("in.snazzle", "r");
	// make sure it's valid:
	if (!myfile) {
		cout &lt;&lt; "I can't open a.snazzle.file!" &lt;&lt; endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:
	
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	<b>cout &lt;&lt; "EEK, parse error on line " &lt;&lt; line_num &lt;&lt; "!  Message: " &lt;&lt; s &lt;&lt; endl;</b>
	// might as well halt now:
	exit(-1);
}
</pre>
<p>Which is pretty cool when you make a "type oops" definition in the middle of the body instead
of where it's supposed to be:
</p><p></p><pre class="snippet">% make
bison -d snazzle.y
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
type oops
7 8 12 13 bas
78 124 100 256 bar
end
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
EEK, parse error on line 7!  Message: syntax error
%
</pre>
<p>Of course, "syntax error" isn't very helpful, but at least you've got the line number.  :)
</p><p></p><p></p><p><a name="9"></a>
</p><h1>Tips</h1>
<p><a name="10"></a>
</p><h2>directly returning terminal characters</h2>
<p>If you have individual characters that are also terminal symbols, you can have Flex
return them directly instead of having to create a <code>%token</code> for them:
</p><pre class="snippet">\(                { return '('; }
;                 { return ';'; }
</pre>
You could also list a bunch of them in a single line with this shortcut:
<pre class="snippet">[\(\)\{\}:;=,]    { return yytext[0]; }
</pre>
<p>On the Bison side, you can also use them directly:
</p><pre class="snippet">thing: FOO '(' BAR ';'
</pre>
<p></p><p><a name="11"></a>
</p><h2>actions before the end of the grammar</h2>
<p>The coolest thing I've discovered about Bison so far is that you can put
action statements <i>in the middle of the grammar</i> instead of just at
the end.  This means you can get information as soon as it's read, which I
find is very useful.  For example, a C++ function call might look like this:
</p><pre class="snippet">functioncall:
	returntype name '(' args ')' body
</pre>
You can always add actions at the end of the line, like this:
<pre class="snippet">functioncall:
	returntype name '(' args ')' body { cout &lt;&lt; "defined function '" &lt;&lt; $2 &lt;&lt; "'' &lt;&lt; endl; }
</pre>
But then you get the function name after 'body' is evaluated, which means the whole thing
has been parsed before you find out what it was!  However, you can embed the code block
in the middle of the grammar and it will be run before 'body' is evaluated:
<pre class="snippet">functioncall:
	returntype name { cout &lt;&lt; "defining function '" &lt;&lt; $2 &lt;&lt; &lt;&lt; endl; } '(' args ')' body
</pre>
<p><a name="12"></a>
</p><h2>whitespace in flex/bison files</h2>
<p>I've discovered that, unlike most unix tools, Flex and Bison are surprisingly lenient about
whitespacing.  This is really nice, because it's hard enough to understand their syntax
without the ability to reindent things.  The following are all equivalent:
</p><pre class="snippet">thing: FOO ':' BAR { cout &lt;&lt; "found a foo-bar!" &lt;&lt; endl; }
	| BAS ':' BAR { cout &lt;&lt; "found a bas-bar!" &lt;&lt; endl; }

thing:
	FOO ':' BAR { cout &lt;&lt; "found a foo-bar!" &lt;&lt; endl; }
	|
	BAS ':' BAR { cout &lt;&lt; "found a bas-bar!" &lt;&lt; endl; }

thing:
	FOO ':' BAR {
		cout &lt;&lt; "found a foo-bar!" &lt;&lt; endl; }
	| BAS ':' BAR {
		cout &lt;&lt; "found a bas-bar!" &lt;&lt; endl; }
</pre>
<p></p><p><a name="13"></a>
</p><h2>avoiding -lfl and link problems with yywrap</h2>
<p>If you know that you only want to parse one file at a time (usually a good
assumption), you don't need to provide your own yywrap function that would just
<code>return 1</code>.  Inside your flex file, you can say <code>%option noyywrap</code> and the
generated output will define <code>yywrap</code> as a local macro returning 1.  This has
the added bonus of removing the requirement to link with the flex libraries, since
they're only needed to get the default <code>yywrap</code> defined as a function returning 1.
</p><p></p><p><a name="14"></a>
</p><h2>renaming identifiers</h2>
<p>Flex and Bison generate code that uses the global namespace, which means that
if you ever try to have more than one in a single program you're going to
have identifier collisions.  To get around that, you can tell both Flex and
Bison to prefix their identifiers with a custom string you specify.
</p><p>In Flex, you can use either the command line option <b>-P foo</b> or the
option syntax <b>%option prefix="foo"</b> in the first section of the file.
</p><p>In Bison, you can use either the command line option <b>-p foo</b> or the
option syntax <b>%name-prefix "foo"</b>.
</p><p></p><p><a name="15"></a>
</p><h2>moving output</h2>
<p>Similar to why you rename identifiers, you usually don't want to use the
default output file names because multiple parsers will all step on each
other.
</p><p>In Flex, you can specify either <b>-o lex.foo.cc</b> on the command line 
(it has to be before your input file!) or
<b>%option outfile="lex.foo.cc"</b> in the first section of the .l file.
</p><p>In Bison, you can specify either <b>-o "foo.tab.cc"</b> on the command
line or <b>%output "foo.tab.cc"</b> in the first section of the .y file.
However, Bison usually names its output after its input anyway; an input
file named "foo.y" will already generate "foo.tab.c".
</p><p></p><p></p><p><a name="16"></a>
</p><h1>Advanced</h1>
<p><a name="17"></a>
</p><h2>start states</h2>
<p>In a Flex/Bison grammer, it is almost impossible to allow multiline commenting such
as C's <code>/* .. */</code>.  What you really want is for the parser go into a
sort of
"ignore everything" state when it sees "/*", and go back to normal when it
sees "*/".  Clearly you wouldn't want Bison to do this, or else you'd have to put
optional 'comment' targets all over every contruct in your syntax; you
can see how it fell to Flex to implement some way to do this.
</p><p>Flex allows you to specify <i>start states</i>, which are just regex pattern rules like
any other <b>but they're only matched if you're in a particular state</b>.  The syntax
for a pattern that should only be matched if we're in state 'FOO' looks like this:
</p><p></p><pre class="snippet">&lt;FOO&gt;bar     ;  // we're in state FOO and we saw "bar"
</pre>
<p>Note that <i>you</i> come up with the state names -- they're not predefined or
anything.  Though when you create a state, you do have to declare it in your Flex
file's control section (that's the first section, before the first "%%"):
</p><pre class="snippet">%x FOO
</pre>
<p>So how do you get into the state?  There's a special Flex construct (I think it's
ultimately a C macro) that goes into any regular code block to get there:
</p><pre class="snippet">bar          { BEGIN(FOO); }  // we saw a "bar", so go into the "FOO" state
</pre>
And how about getting back out of that state and going back to where you were
initially?  Instead of somthing obvious (say, "END()"?), they decided to make a
default state called "INITIAL."  Any Flex match pattern that doesn't have a
state in front of it is assumed to be in the INITIAL state.  To get back to
it, you just jump to it:
<pre class="snippet">bas          { BEGIN(INITIAL); }  // jump back to normal pattern matching
</pre>
Note that the BEGIN thing is for all intents and purposes normal C code, despite the
fact that it's not.  :)  What that means is that you can treat it like code and put it
anywhere you want -- you can even make it conditional:
<pre class="snippet">bar          { do_something(); BEGIN(FOO); do_something_else(); }
..
bar          { if (some_value == 42) BEGIN(FOO); }
..
</pre>
<p>Back to the original problem -- multiline commenting.  Here's a way to do C-style
block commenting using start states:
</p><p></p><pre class="snippet">\/\*                    { // start of a comment: go to a 'COMMENTS' state.
	BEGIN(COMMENTS);
	}
&lt;COMMENTS&gt;\*\/    {   // end of a comment: go back to normal parsing.
	BEGIN(INITIAL);
	}
&lt;COMMENTS&gt;\n      { ++linenum; }   // still have to increment line numbers inside of comments!
&lt;COMMENTS&gt;.       ;   // ignore every other character while we're in this state
</pre>
<p>Note that you can also have a Flex match pertain to <i>multiple</i> states by listing them all:
</p><p></p><pre class="snippet">&lt;MYSTATE,ANOTHERSTATE&gt;foo { ... }
</pre>
This occasionally comes in handy, such as keeping you from having to duplicate
the line-counting pattern/code above.
<p></p><p><a name="18"></a>
</p><h2>reading gzipped input</h2>
<p>This is, surprisingly, rather easy.  The basic idea is to filter Flex's input
through libz.  libz is very nice because it will pass through, unchanged, any
input which isn't zipped -- so we don't need to check if the input is zipped
and handle it differently!
</p><p>For reference, the API to libz is available
<a href="http://www.gzip.org/zlib/manual.html">here</a> (last I looked).
I have been consistently surprised with how easy it is to use
libz directly to avoid silly hacks like "popen"ing "gunzip -c" and redirecting
its output.  Kudos to the libz team!
</p><p>In the first section of your Flex file, you'll want to declare that you have a better input
function, and then tell Flex it has to use yours instead:
</p><pre class="snippet">extern int my_abstractread(char *buff, int buffsize);
#define YY_INPUT(buff, res, buffsize) (res = my_abstractread(buff, buffsize))
</pre>
<p>Somewhere or another (I put it in my top-level files because it doesn't have to go
in with the Flex/Bison source) you need to define your input function.  Mine looks like this:
</p><p></p><pre class="snippet">#include &lt;zlib.h&gt;  // direct access to the gzip API

// (ew!) global variable for the gzip stream.
gzFile my_gzfile = 0;

int my_abstractread(char *buff, int buffsize) {

	// called on a request by Flex to get the next 'buffsize' bytes of data
	// from the input, and return the number of bytes read.

	int res = gzread(my_gzfile, buff, buffsize);
	if (res == -1) {
		// file error!
		abort();
	}

	return res;
}
</pre>
<p>Then, instead of using <code>fopen</code>, you use libz:
</p><pre class="snippet">// libz is very nice in that it handles unzipped files as well, which
// means that no matter what the input file is we can just pass it
// through gzopen and not worry about it:
my_gzfile = gzopen(filename.c_str(), "r");
if (!my_gzfile)  {
	// file cannot be opened
	abort();
}
</pre>
<p>And finally, you have to change your yyparse()-calling loop to use these
new file handles instead of yyin:
</p><pre class="snippet">do {
	myparse();
} while (!gzeof(my_gzfile));
</pre>
<p></p><p><a name="19"></a>
</p><h1>Regular expression overview</h1>
<p>You've used regexs before without knowing it, for example when you use
wildcards on file names:
</p><p></p><pre class="snippet">  % ls *asdf*
  asdf
  asdf2
  asdf3
  new.asdf
  new.asdf.mangled
  %
</pre>
<p>The shell's idea of regular expressions isn't quite accurate with the "real"
definition of regular expressions, but at least the idea is the same.  Here,
we're telling ls to list all the files that have "asdf" somewhere in the name.
We could ask for just the files <i>starting</i> with asdf by saying "asdf*",
or all the files ending with asdf with "*asdf".  The asterisk basically means
"anything can go here".
</p><p>Regular expressions are really just the scientific deconstruction of such
pattern matching.  As such, you can imagine they're not a whole lot
of fun.  :)  There's actually an entire O'Reilly book dedicated to them, if
you really want to see what they're all about. (I'd love to make a wisecrack
about being great for insomnia, but right now it's ranked #5,076 on Amazon's
sales rank.  Guess it can't be too unbearable!)
</p><p>With that said, my little overview here is clearly not
going to be exhaustive, but should give you the general idea.  Flex's regular
expressions consist of "characters" and "meta-characters".  "Characters" are interpreted
literally as real text, whereas "meta-characters" change how the search works.  For example,
listing "foo" as a regular expression will match exactly one string, which is "foo".  But
if you add the metacharacter "+" (which means "one or more of the previous
character") after the "f" to get "f+oo", it will match "foo", "ffoo",
and "ffffffffffffffffoo".  A table of meta-characters follows:
</p><p></p><table border="1" align="center" cellpadding="4">
<tbody><tr><td><b>metacharacter</b></td><td><b>description</b></td></tr>
<tr><td align="center">+</td><td>previous expression can match one or more times</td></tr>
<tr><td align="center">*</td><td>previous expression can match zero or more times</td></tr>
<tr><td align="center">?</td><td>previous expression can match zero or one time</td></tr>
<tr><td align="center">.</td><td>can match any character except the carriage return '\n'</td></tr>
</tbody></table>
<p>I say "expression" above instead of just "character" because you can also make
groups of things by enclosing whatever you want in parentheses.
</p><p>Brackets are very cool -- by saying "[abcde]", it will match any <i>one</i> of the characters
in the brackets, so you'll match "a" and "b" but not "ac".  If you add a plus after
the closing bracket, though, then you <i>will</i> match "ac" as well.
Brackets
also allow negation: "[^abc]" will match anything that's not in the brackets, so "d" and "foo" would
pass but not "b".
</p><p>Most useful of all, brackets allow for ranges: "[a-e]" is the same as "[abcde]".  So
you will frequently see stuff like "[0-9]+" to match integer values, or
"[a-zA-Z]+" to match words, etc.
</p><p>So how do you match an actual bracket, or an actual period, if the regular expression
searcher is immediately going to think you're defining a meta-character?  By adding
a backslash (\) in front of it!  So "a\.b" will match the string "a.b" but not "acb", whereas
"a.b" as a regular expression will match both.  And to be complete, backslash itself
can be backslashed, so that "a\\." will match the string "a\b".  (What fun!)
</p><p>This stuff just takes some playing with to get used to.  It's not really that bad.  :)
</p><hr width="80%" align="center">
<i><a href="mailto:chris@aquamentus.com">Chris verBurg</a><br>
2015-03-08<br></i>

</body></html>