#ifndef ASS4_15CS30044_TRANSLATOR_H
#define ASS4_15CS30044_TRANSLATOR_H
#define size_of_int 4
#define size_of_double 8
#define size_of_pointer 4
#define size_of_char 1
#define size_of_bool 1

#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <set>
#include <map>
#include <stack>


using namespace std;

class quad; //to define quad so that we can further use it to make array
class symdata; //to enter data into symbol table
class symtab; //usual symbol table
class quad_arr; //it stores the list of quads for the expression and also emits the required emits
struct expresn;
struct arglistStr;

extern int glob_type; //to store the global type for inherited attributes
extern int next_instr,start_instr; //next instr for use in quads and in different function like backpatch
extern int temp_count; // count of the temporary varibles to name the new temporary variable
extern symtab *glob_st; //Global symbol table pointer
extern symtab *curr_st; //Current Symbol table pointer
extern quad_arr glob_quad; //to store all the quads that will be generated by the grammar
extern char str_of_int[5],str_of_2_int[5],str_of_double[5];

enum types{
	tp_not_set=0,tp_void,tp_bool,tp_char,tp_int,tp_double,tp_ptr,tp_func,tp_matrix
};

typedef struct list{
	int index;
	struct list *next;
}list;

enum opcode{

	//Binary Assignment Operator
	Q_PLUS=1,Q_MINUS,Q_MULT,Q_DIVIDE,Q_MODULO,Q_LEFT_OP,Q_RIGHT_OP,
	Q_XOR,Q_AND,Q_OR,Q_LOG_AND,Q_LOG_OR,Q_LESS,Q_LESS_OR_EQUAL,
	Q_GREATER_OR_EQUAL,Q_GREATER,Q_EQUAL,Q_NOT_EQUAL,

	//Unary Assignment Operator
	Q_UNARY_MINUS,Q_UNARY_PLUS,Q_COMPLEMENT,Q_NOT,

	//Copy Assignment
	Q_ASSIGN,

	//Unconditional Jump
	Q_GOTO,
	
	//Unary conditional jump
	Q_IF_EXPRESSION,Q_IF_FALSE_EXPRESSION,

	//Conditional Jump
	Q_IF_EQUAL,Q_IF_NOT_EQUAL,
	Q_IF_LESS,Q_IF_GREATER,Q_IF_LESS_OR_EQUAL,Q_IF_GREATER_OR_EQUAL,

	//Type Conversions
	Q_CHAR2INT,Q_CHAR2DOUBLE,Q_INT2CHAR,Q_DOUBLE2CHAR,Q_INT2DOUBLE,Q_DOUBLE2INT,

	//Procedure Call
	Q_PARAM,Q_CALL,Q_RETURN,Q_START,

	//Pointer Assignment Operator
	Q_LDEREF,Q_RDEREF,
	Q_ADDR,

	//Array Indexing
	Q_RINDEX,
	Q_LINDEX,

};

void int2str(int a,char *str);
void double2str(double d,char *str);


//it is the basic type that an element can have
union basic_value{
	char c;
	int i;
	double d;
};

struct matrix_row
{
	vector<double> matrow;
};

class matrix
{
public:
	//string base_matrix;
	int number_rows;
	int number_cols;
	vector<vector <double> > mat;
};


//class which will be used as building element for symbol table
class symdata{
public:
	string name;//to store the value of a varaible stored in symbol table
	int size; //to stoe the size of an element in a symbol table
	int offset;//to maintain the offset at this variable to know the position at symbol table
	basic_value init;//to store the initialized value for an element stored at symbol table
	bool isInitialized; //If the value of element is initialized or not
	int tp;
	int tp_of_ptr;
	string var_type;//to store whether the varaible is "null=0" "local=1" "param=2" "func=3" "ret=4" "temporary=5"
	symtab *nest_tab; //to store the pointer to the symbol table to which the current element belongs to
	matrix *mat;
	symdata();
	symdata(string name,int offset,string var_type,int tp,int tp_of_ptr = tp_not_set);
	void setbasic(basic_value init);
	void setsize();
	int getsize();
	void putsizename(char* str);
};	

class symtab{
public:
	string name;			// name of the symbol
	int offset;				// final offset of this symbol table that will be used in the update function
	vector<symdata*> symbol_tab; //maintaining a list of symbol tables
	symtab();  //constructor
	symdata* lookup(symdata* newsym);// Lookup function searches the variable with name. If the variable is present then returns its pointer location else creates a new entry with its name and returns that pointer
	symdata* search(string n); //it searches for the variable and returns the oiter to it if present
	symdata* gentemp(int tp,int tp_of_ptr = tp_not_set); //gentemp creates a new element in the symbol table with the type provided at the time of constructing
	void update(symdata *sm,int tp,basic_value init);
	void print();
};

struct expresn{
	symdata* loc;
	list* truelist;
	list* falselist;
	bool do_dereference;
	bool do_indexing;
	symdata *sym_index;
};

list* makelist(int i);  //creates a list have only one element as i
list* merge(list *l1,list *l2); //merges the the two list and return a merged list
void backpatch(list *l,int i);  //to fill the dangling list of goto's l1 to i
void conv2Bool(expresn *e); //to convert the given exprssion type to bool mostly used in relational operator
void typecheck(expresn *e1,expresn *e2,bool isAss = false);
void print_list(list *root);


class quad{
public:
	string arg1,arg2,result; //consist of three elements 
	opcode op;
	quad(opcode,string,string,string); //constructorparameters
};

struct arglistStr
{
	vector<expresn*> *arguments;		// A simple vector is used to store the locations of all seen arguments
};

class quad_arr{
public:
	vector<quad> arr;//to store the list of quads
	quad_arr();
	void emit(opcode opc, char val, string operand=""); //emit for assignment of char
	void emit(opcode opc, int val, string operand="");  // emit for assignment of integer
	void emit(opcode opc, double val, string operand=""); //emit for assignment of double
	void emit(opcode opc, string arg1="", string arg2="", string result=""); //emit used for operations with 3 inputs
	void print();  //print all the quads
};

#endif
